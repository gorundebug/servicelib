digraph {
"api.DataConnector" -> { "api.string" "api.DataConnectorImplementation" "api.int" "api.ProgrammingLanguage" "api.DataConnectorType" };
"api.Endpoint" -> { "api.int" "api.DataFormat" "api.string" "api.bool" };
"api.Link" -> { "api.CallSemantics" "api.CommunicationProtocol" "api.bool" "api.string" "api.int" };
"api.Service" -> { "api.CallSemantics" "api.LogLevel" "api.ProgrammingLanguage" };
"api.Stream" -> { "api.bool" "api.TransformationType" "api.int" "api.JoinStorageType" "api.JoinType" "api.string" };
"api.StreamApp" -> { "api.Stream" "api.Type" "api.DataConnector" "api.Endpoint" "api.Link" "api.Pool" "api.Service" "api.ProjectSettings" };
"api.Type" -> { "api.TypeDefinitionFormat" "api.string" "api.bool" "api.DataType" };
"api.ServerInterfaceWrapper" -> { "api.ServerInterface" "api.MiddlewareFunc" };
"api.UnescapedCookieParamError" -> { "api.error" };
"api.UnmarshalingParamError" -> { "api.error" };
"api.RequiredHeaderError" -> { "api.error" };
"api.InvalidParamFormatError" -> { "api.error" };
"api.GorillaServerOptions" -> { "mux.Router" "api.MiddlewareFunc" };
"localsink.CustomDataSink" -> { "runtime.OutputDataSink" "sync.WaitGroup" };
"localsink.CustomEndpoint" -> { "runtime.DataSinkEndpoint" };
"localsink.TypedCustomEndpointConsumer[T any]" -> { "runtime.DataSinkEndpointConsumerT" "localsink.DataConsumerT" };
"http.NetHTTPDataSource" -> { "runtime.InputDataSource" "http.Server" "http.ServeMux" "http.struct" };
"http.NetHTTPEndpoint" -> { "runtime.DataSourceEndpoint" };
"http.netHTTPEndpointRequestData" -> { "http.byte" "url.Values" "http.ResponseWriter" "http.Request" };
"http.NetHTTPEndpointTypedConsumer[T any]" -> { "runtime.DataSourceEndpointConsumerT" };
"http.NetHTTPEndpointJsonConsumer[T any]" -> { "http.NetHTTPEndpointTypedConsumerT" "reflect.Type" };
"http.NetHTTPEndpointFormConsumer[T any]" -> { "http.NetHTTPEndpointTypedConsumerT" "reflect.Type" "schema.Decoder" };
"localsource.CustomDataSource" -> { "runtime.InputDataSource" "sync.WaitGroup" };
"localsource.CustomEndpoint" -> { "runtime.DataSourceEndpoint" "time.Duration" };
"localsource.TypedCustomEndpointConsumer[T any]" -> { "runtime.DataSourceEndpointConsumerT" "localsource.DataProducerT" "sync.WaitGroup" };
"runtime.AppSinkStream[T any]" -> { "runtime.TypedStreamT" "runtime.ServiceStreamT" "runtime.ConsumerFuncT" };
"runtime.collector[T any]" -> { "runtime.CallerT" };
"runtime.parallelsCollector[T any]" -> { "runtime.CallerT" };
"config.StreamConfig" -> { "api.Stream" };
"config.ServiceConfig" -> { "api.Service" };
"config.LinkConfig" -> { "api.Link" };
"config.DataConnectorConfig" -> { "api.DataConnector" };
"config.EndpointConfig" -> { "api.Endpoint" };
"config.ProjectSettings" -> { "api.ProjectSettings" };
"config.RuntimeConfig" -> { "config.StreamConfig" "config.ServiceConfig" "config.LinkId" "config.LinkConfig" "config.DataConnectorConfig" "config.EndpointConfig" "config.PoolConfig" };
"config.ServiceAppConfig" -> { "config.StreamConfig" "config.ServiceConfig" "config.LinkConfig" "config.DataConnectorConfig" "config.EndpointConfig" "config.PoolConfig" "config.ProjectSettings" "config.RuntimeConfig" };
"runtime.OutputDataSink" -> { "runtime.ServiceExecutionEnvironment" "runtime.SinkEndpoint" };
"runtime.DataSinkEndpoint" -> { "runtime.ServiceExecutionEnvironment" "runtime.DataSink" "runtime.OutputEndpointConsumer" };
"runtime.DataSinkEndpointConsumer[T any]" -> { "runtime.SinkEndpoint" "runtime.TypedSinkStreamT" "runtime.TypedEndpointWriterT" };
"runtime.InputDataSource" -> { "runtime.ServiceExecutionEnvironment" "runtime.InputEndpoint" };
"runtime.DataSourceEndpoint" -> { "runtime.ServiceExecutionEnvironment" "runtime.DataSource" "runtime.InputEndpointConsumer" };
"runtime.DataSourceEndpointConsumer[T any]" -> { "runtime.InputEndpoint" "runtime.TypedEndpointReaderT" "runtime.TypedInputStreamT" };
"datastruct.KeyValue[K comparable, V any]" -> { "datastruct.K" "datastruct.V" };
"runtime.DelayFunctionContext[T any]" -> { "runtime.StreamFunctionT" "runtime.TypedStreamT" "runtime.DelayFunctionT" };
"runtime.DelayStream[T any]" -> { "runtime.TypedStreamT" "runtime.DelayFunctionContextT" "runtime.ConsumedStreamT" };
"metrics.Opts" -> { "metrics.Labels" };
"metrics.CounterOpts" -> { "metrics.Opts" };
"metrics.SummaryOpts" -> { "metrics.Opts" "time.Duration" };
"metrics.GaugeOpts" -> { "metrics.Opts" };
"metrics.HistogramOpts" -> { "metrics.Opts" "metrics.float64" "time.Duration" };
"runtime.FilterFunctionContext[T any]" -> { "runtime.StreamFunctionT" "runtime.TypedStreamT" "runtime.FilterFunctionT" };
"runtime.FilterStream[T any]" -> { "runtime.ConsumedStreamT" "runtime.TypedStreamT" "runtime.FilterFunctionContextT" };
"runtime.FlatMapFunctionContext[T, R any]" -> { "runtime.TypedStreamR" "runtime.R" "runtime.StreamFunctionR" };
"runtime.FlatMapStream[T, R any]" -> { "runtime.ConsumedStreamR" "runtime.TypedStreamT" "runtime.R" };
"runtime.FlatMapIterableStream[T, R any]" -> { "runtime.ConsumedStreamR" "runtime.TypedStreamT" };
"runtime.ForEachFunctionContext[T any]" -> { "runtime.StreamFunctionT" "runtime.TypedStreamT" "runtime.ForEachFunctionT" };
"runtime.ForEachStream[T any]" -> { "runtime.ConsumedStreamT" "runtime.TypedStreamT" "runtime.ForEachFunctionContextT" };
"runtime.InputStream[T any]" -> { "runtime.ConsumedStreamT" };
"runtime.JoinFunctionContext[K comparable, T1, T2, R any]" -> { "runtime.StreamFunctionR" "runtime.TypedStreamR" "runtime.R" };
"runtime.JoinLink[K comparable, T1, T2, R any]" -> { "runtime.T2" "runtime.R" };
"runtime.JoinStream[K comparable, T1, T2, R any]" -> { "runtime.ConsumedStreamR" "runtime.R" "runtime.T1" "store.JoinStorageK" "api.JoinType" };
"runtime.joinStorageConfig" -> { "runtime.Stream" };
"runtime.KeyByFunctionContext[T any, K comparable, V any]" -> { "runtime.V" };
"runtime.KeyByStream[T any, K comparable, V any]" -> { "runtime.V" "runtime.TypedStreamT" };
"runtime.LinkStream[T any]" -> { "runtime.ConsumedStreamT" "runtime.TypedConsumedStreamT" };
"logrus.LogEngine" -> { "environment.ServiceEnvironment" };
"logrus.Logger" -> { "logrus.Logger" };
"runtime.MapFunctionContext[T, R any]" -> { "runtime.StreamFunctionR" "runtime.TypedStreamR" "runtime.R" };
"runtime.MapStream[T, R any]" -> { "runtime.TypedStreamT" "runtime.R" "runtime.ConsumedStreamR" };
"runtime.MergeStream[T any]" -> { "runtime.ConsumedStreamT" "runtime.MergeLinkT" };
"runtime.MergeLink[T any]" -> { "runtime.MergeStreamT" "runtime.TypedStreamT" };
"runtime.MultiJoinFunctionContext[K comparable, T, R any]" -> { "runtime.StreamFunctionR" "runtime.TypedStreamR" "runtime.R" };
"runtime.MultiJoinLinkStream[K comparable, T1, T2, R any]" -> { "runtime.R" "serde.SerdeT2" "runtime.T2" };
"runtime.MultiJoinStream[K comparable, T, R any]" -> { "runtime.T" "store.JoinStorageK" "runtime.ConsumedStreamR" "runtime.R" "runtime.multiJoinLinkStream" };
"runtime.ParallelsFunctionContext[T, R any]" -> { "runtime.TypedStreamR" "runtime.R" "runtime.StreamFunctionR" };
"runtime.ParallelsStream[T, R any]" -> { "runtime.ConsumedStreamR" "runtime.TypedStreamT" "runtime.R" };
"pool.DelayTask" -> { "time.Time" "pool.DelayTask" };
"pool.DelayPoolImpl" -> { "pool.DelayTaskPriorityQueue" "sync.Mutex" "pool.struct" "metrics.Gauge" "pool.DelayTask" "environment.ServiceEnvironment" "sync.WaitGroup" "time.Timer" "sync.Cond" };
"pool.PriorityTaskPoolImpl" -> { "environment.ServiceEnvironment" "sync.Mutex" "pool.TaskPriorityQueue" "metrics.Gauge" "sync.WaitGroup" "sync.Cond" };
"pool.Task" -> { "pool.Task" };
"pool.TaskPoolImpl" -> { "pool.Task" "sync.Mutex" "metrics.Gauge" "sync.WaitGroup" "sync.Cond" "environment.ServiceEnvironment" };
"serviceLoader[Environment ServiceExecutionEnvironment, Cfg config.Config]" -> { "sync.WaitGroup" "runtime.Environment" "fsnotify.Watcher" };
"runtime.consumeStatistics" -> { "atomic.Int64" };
"runtime.caller[T any]" -> { "runtime.consumeStatistics" "runtime.TypedStreamT" "runtime.TypedStreamConsumerT" };
"runtime.directCaller[T any]" -> { "runtime.callerT" };
"runtime.taskPoolCaller[T any]" -> { "runtime.callerT" "pool.TaskPool" };
"runtime.priorityTaskPoolCaller[T any]" -> { "runtime.callerT" "pool.PriorityTaskPool" };
"runtime.ServiceStream[T any]" -> { "runtime.ServiceExecutionEnvironment" };
"runtime.ConsumedStream[T any]" -> { "serde.StreamSerdeT" "runtime.TypedStreamConsumerT" "runtime.ServiceStreamT" "runtime.CallerT" };
"runtime.StreamFunction[T any]" -> { "runtime.ServiceStreamT" };
"serde.streamSerde[T any]" -> { "serde.SerdeT" };
"serde.streamKeyValueSerde[K comparable, V any]" -> { "serde.SerdeK" "serde.SerdeV" };
"serde.arraySerde" -> { "reflect.Type" "serde.Serializer" };
"serde.ArraySerde[T any]" -> { "serde.arraySerde" };
"serde.mapSerde" -> { "reflect.Type" "serde.Serializer" };
"serde.MapSerde[T any]" -> { "serde.mapSerde" };
"runtime.MockServiceConfig" -> { "config.ServiceAppConfig" };
"runtime.MockService" -> { "runtime.ServiceApp" "runtime.MockServiceConfig" };
"runtime.ServiceApp" -> { "pool.PriorityTaskPool" "runtime.DataSource" "http.ServeMux" "metrics.MetricsEngine" "config.LinkId" "runtime.ConsumeStatistics" "store.Storage" "runtime.DataSink" "reflect.Type" "metrics.Metrics" "pool.TaskPool" "runtime.ServiceLoader" "atomic.Pointerconfig.ServiceAppConfig" "runtime.ServiceExecutionEnvironment" "runtime.Stream" "http.Server" "pool.DelayPool" "environment.ServiceDependency" "serde.StreamSerializer" "runtime.struct" "log.LogsEngine" "log.Logger" };
"runtime.SinkStream[T any]" -> { "runtime.ServiceStreamT" "runtime.TypedStreamT" "runtime.ConsumerT" };
"runtime.SplitLink[T any]" -> { "runtime.SplitStreamT" "runtime.CallerT" "runtime.TypedStreamConsumerT" };
"runtime.SplitStream[T any]" -> { "runtime.ConsumedStreamT" "runtime.SplitLinkT" "runtime.TypedStreamT" };
"runtime.InputSplitStream[T any]" -> { "runtime.SplitStreamT" };
"runtime.InputKVSplitStream[T any]" -> { "runtime.SplitStreamT" "serde.StreamKeyValueSerdeT" };
"store.Item" -> { "sync.Mutex" "time.Time" "store.interface" };
"store.HashMapJoinStorage[K comparable]" -> { "store.Item" "sync.RWMutex" "time.Timer" "store.JoinStorageConfig" "metrics.Gauge" "environment.ServiceEnvironment" "store.K" };
"runtime.InStubStream[T any]" -> { "runtime.ConsumedStreamT" };
"runtime.InStubKVStream[T any]" -> { "runtime.ConsumedStreamT" "serde.StreamKeyValueSerdeT" };
"runtime.OutStubStream[T any]" -> { "runtime.ServiceStreamT" "runtime.ConsumerFuncT" "runtime.TypedStreamT" };
"runtime.OutStubBinaryStream[T any]" -> { "runtime.ServiceStreamT" "runtime.TypedStreamT" "serde.StreamSerdeT" "runtime.BinaryConsumerFunc" };
"runtime.OutStubBinaryKVStream[T any]" -> { "runtime.ServiceStreamT" "runtime.TypedStreamT" "serde.StreamKeyValueSerdeT" "runtime.BinaryKVConsumerFunc" };
"prometheus.CounterVec" -> { "prometheus.CounterVec" };
"prometheus.SummaryVec" -> { "prometheus.SummaryVec" };
"prometheus.GaugeVec" -> { "prometheus.GaugeVec" };
"prometheus.HistogramVec" -> { "prometheus.HistogramVec" };
"prometheus.MetricsEngine" -> { "environment.ServiceEnvironment" "prometheus.Metrics" };
"runtime.Collection[T any]" -> { "runtime.T" };
"mockservice.MockServiceConfig" -> { "config.ServiceAppConfig" };
"mockservice.MockService" -> { "mockservice.RequestData" "runtime.ServiceApp" "mockservice.MockServiceConfig" "runtime.TypedStreamConsumerRequestData" "runtime.TypedInputStreamRequestData" "runtime.ConsumerRequestData" };
}